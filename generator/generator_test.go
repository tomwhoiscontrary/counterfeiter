package generator_test

import (
	"github.com/maxbrunsfeld/counterfeiter/locator"

	. "github.com/maxbrunsfeld/counterfeiter/generator"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe("Generator", func() {
	var subject CodeGenerator

	BeforeEach(func() {
		model, _ := locator.GetInterfaceFromFilePath("Something", "../fixtures/something.go")

		subject = CodeGenerator{
			Model:       *model,
			StructName:  "FakeSomething",
			PackageName: "fixturesfakes",
		}
	})

	Describe("generating a fake for a simple interface", func() {
		var fakeFileContents string
		var err error

		BeforeEach(func() {
			fakeFileContents, err = subject.GenerateFake()
		})

		It("should not fail", func() {
			Expect(err).ToNot(HaveOccurred())
		})

		It("should match the correct file contents", func() {
			Expect(fakeFileContents).To(Equal(`// This file was generated by counterfeiter
package fixturesfakes

import (
	"sync"

	"github.com/maxbrunsfeld/counterfeiter/fixtures"
)

type FakeSomething struct {
	DoThingsStub        func(string, uint64) (int, error)
	doThingsMutex       sync.RWMutex
	doThingsArgsForCall []struct {
		arg1 string
		arg2 uint64
	}
	doThingsReturns struct {
		result1 int
		result2 error
	}
	DoNothingStub        func()
	doNothingMutex       sync.RWMutex
	doNothingArgsForCall []struct{}
}

func (fake *FakeSomething) DoThings(arg1 string, arg2 uint64) (int, error) {
	fake.doThingsMutex.Lock()
	fake.doThingsArgsForCall = append(fake.doThingsArgsForCall, struct {
		arg1 string
		arg2 uint64
	}{arg1, arg2})
	fake.doThingsMutex.Unlock()
	if fake.DoThingsStub != nil {
		return fake.DoThingsStub(arg1, arg2)
	} else {
		return fake.doThingsReturns.result1, fake.doThingsReturns.result2
	}
}

func (fake *FakeSomething) DoThingsCallCount() int {
	fake.doThingsMutex.RLock()
	defer fake.doThingsMutex.RUnlock()
	return len(fake.doThingsArgsForCall)
}

func (fake *FakeSomething) DoThingsArgsForCall(i int) (string, uint64) {
	fake.doThingsMutex.RLock()
	defer fake.doThingsMutex.RUnlock()
	return fake.doThingsArgsForCall[i].arg1, fake.doThingsArgsForCall[i].arg2
}

func (fake *FakeSomething) DoThingsReturns(result1 int, result2 error) {
	fake.DoThingsStub = nil
	fake.doThingsReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSomething) DoNothing() {
	fake.doNothingMutex.Lock()
	fake.doNothingArgsForCall = append(fake.doNothingArgsForCall, struct{}{})
	fake.doNothingMutex.Unlock()
	if fake.DoNothingStub != nil {
		fake.DoNothingStub()
	}
}

func (fake *FakeSomething) DoNothingCallCount() int {
	fake.doNothingMutex.RLock()
	defer fake.doNothingMutex.RUnlock()
	return len(fake.doNothingArgsForCall)
}

var _ fixtures.Something = new(FakeSomething)
`))
		})
	})

	Describe("generating a fake for a typed function", func() {
		var fakeFileContents string
		var err error

		BeforeEach(func() {
			model, _ := locator.GetInterfaceFromFilePath("RequestFactory", "../fixtures/request_factory.go")

			subject = CodeGenerator{
				Model:       *model,
				StructName:  "FakeRequestFactory",
				PackageName: "fixturesfakes",
			}
			fakeFileContents, err = subject.GenerateFake()
		})

		It("should not fail", func() {
			Expect(err).ToNot(HaveOccurred())
		})

		It("should produce the correct file contents", func() {
			Expect(fakeFileContents).To(Equal(`// This file was generated by counterfeiter
package fixturesfakes

import (
	"sync"

	"github.com/maxbrunsfeld/counterfeiter/fixtures"
	"github.com/maxbrunsfeld/counterfeiter/model"
)

type FakeRequestFactory struct {
	Stub        func(model.InterfaceToFake, map[string]interface{}) (model.InterfaceToFake, error)
	mutex       sync.RWMutex
	argsForCall []struct {
		arg1 model.InterfaceToFake
		arg2 map[string]interface{}
	}
	returns struct {
		result1 model.InterfaceToFake
		result2 error
	}
}

func (fake *FakeRequestFactory) Spy(arg1 model.InterfaceToFake, arg2 map[string]interface{}) (model.InterfaceToFake, error) {
	fake.mutex.Lock()
	fake.argsForCall = append(fake.argsForCall, struct {
		arg1 model.InterfaceToFake
		arg2 map[string]interface{}
	}{arg1, arg2})
	fake.mutex.Unlock()
	if fake.Stub != nil {
		return fake.Stub(arg1, arg2)
	} else {
		return fake.returns.result1, fake.returns.result2
	}
}

func (fake *FakeRequestFactory) CallCount() int {
	fake.mutex.RLock()
	defer fake.mutex.RUnlock()
	return len(fake.argsForCall)
}

func (fake *FakeRequestFactory) ArgsForCall(i int) (model.InterfaceToFake, map[string]interface{}) {
	fake.mutex.RLock()
	defer fake.mutex.RUnlock()
	return fake.argsForCall[i].arg1, fake.argsForCall[i].arg2
}

func (fake *FakeRequestFactory) Returns(result1 model.InterfaceToFake, result2 error) {
	fake.Stub = nil
	fake.returns = struct {
		result1 model.InterfaceToFake
		result2 error
	}{result1, result2}
}

var _ fixtures.RequestFactory = new(FakeRequestFactory).Spy
`))
		})
	})
})
